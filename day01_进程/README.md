###虚拟内存空间
1,操作系统位每一个进程虚拟了内存空间。为什么要虚拟内存空间（是为了让n个进程有效的访问物理内存）
2,每一个进程空间的地址，&a, 是逻辑地址。。。
3,逻辑地址是怎么映射到物理地址的？段式管理和页式管理机制就行了。linux 内核模型开发
###进程的概念
1，进程是操作系统对正在运行的任务的一个抽象。
2,早期没有进程的概念，当出现中断技术以后才出现进程的概念 (分式操作系统:基于时间片段轮转)
3,进程状态
    操作系统静态三态	(1)就绪 （2)等待 （3）运行
	因创建而就绪，因调度而执行：因时间片用完而重新就绪
	执行中因I/O操作请求而阻塞
	I/O完成而就绪	
	注意：阻塞以后不能直接执行，必须进入就绪状态
   linux 内核中的进程状态	
	运行状态（TASK_RUNNING）
	可中断睡眠状态（TASK_INTERRUPTIBLE）
	不可中断睡眠状态(TASK_UNINTERRUPTIBLE)
	暂停状态（TASK_STOPPED）
	僵死状态（TASK_ZOMBIE）
4,进程是操作系统对资源的一种抽象，是cpu调度资源的单位.一个进程：代码段，数据段，堆栈段，+进程控制块（pcb）pcb 是操作系统感知进程存在的一个重要数据结构.
	(cpu 通过进程控制块来控制进程)
### 进程和程序的区别
1,进程是动态的，程序是静态的
2，进程的声明周期是相对短暂的，而程序是永久的
3，进程数据结构PCB
4，一个进程只能对应要给程序，一个程序可以对应多个进程
###进程调度以及调度算法
按照一定算法，从一组待运行的进程中选一个来占有cpu运行
1,先来先服务调度算法
2,短进程优先调度算法
3,高优先级优先调度算法
4,时间片轮转发
###进程的创建
1,linux 内核创建O号进程(也系统空闲进程)
2,linux 内核创建第一个用户进程。。1号进程
3,查看内核进程pid的最大配置 cat /proc/sys/kernel/pid_max
4,fork 一次调用二次返回 
  fork 返回==0 是子进程, > 0是父进程,返回值是子进程的id号。是为了很方便的控制子进程.而通过子进程通过getppid获取父进程很方便.
  本质是linxu内核让两个进程，在各自内存空间返回.每个进程都有各自的进程空间
  copy什么？代码，堆栈，数据段，进程控制块PCB
###errno 
1,每一个进程的空间里，默认创建一个变量。errno . perror("title");

###进程数据结构
###写时复制
创建一个子进程的时候，会把数据段，data段 代码段，进程控制块 拷贝给子进程.这里面有一个原则。 写时拷贝原则.这个动作并不是马上执行。
当子进程去修改变量的时候，才会进行拷贝.拷贝的时候，只是去拷贝需要的页.每一进程操作系统都会对他进行分页管理。内存空间2的32次方，是远远大于物理内存的。
对某一页进行拷贝。
###孤儿进程和僵死进程
1,如果父进程先退出，子进程还没有退出，那么子进程的父进程将变为init进程。(注：任何一个进程都必须有父进程). 孤儿进程
2,如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就会成为僵死进程。通过ps -ef 可以看到defunct
3,僵死进程的避免方法：signal(SIGCHLD,SIG_IGN);子进程退出后，发送信号SIGCHILD给父进程，父进程收到信号忽略处理。告诉linux内核，当子进程退出的时候，父进程不收尸，都让linux 内核来做。子进程退出的时候，通过进程控制块来检查进程状态，父进程不收尸，那么linux内核来收尸。
###fork 之后，父子进程共享文件
1,子进程和父进程都有各自的内存空间。
2,文件描述符 0，1，2 标准输入，输出，错误。打开一个新的文件是就是3。新的文件描述符指向一个文件表指针
	        	文件表
        	文件状态标志
         	当前文件偏移量
	        refcnt (引用计数)
	        v节点指针
文件描述符只是一个指针变量，可以通过进程向同一个文件里写东西。因为他们都是使用同一个当前文件偏移量
###fork 和 vfork 都是用来创建进程
1,vfork 出来的早，vfork有限制，子进程必须立刻执行_exit或者exec函数 . 这个函数目的，就是来替换进程.即使fork实现了 .即使fork实现了copy on write 效率也没有vfork高，但是我们不推荐使用vfork,因为几乎每一个vfork的实现，都或多或少的存在一定问题. 

###进程终止的5中方式
1,正常退出。exit(0)是c语言库函数，做了一个清除I/O缓冲区的操作。而_exit 直接嵌入到linux内核中去。printf("helo \n"); \n也相当于清除缓冲区操作.或者调用fflush(stdout)
exit 会执行调用终止处理程序
	从main 函数返回，调用exit ，调用_exit.
	有关终止处理程序
	atexit 可以注册终止处理程序，ANSIC 规定最多可以注册32个终止处理程序。
	终止处理程序的调用与注册次序相反。man atexit
2，异常退出 调用abort 产生SIGABOUT 信号。 由信号终止ctrl+c SIGINT
### 守护进程
1，守护进程是在后台运行不受控制的进程，通常情况下守护进程在系统启动时自动运行。
2,守护进程的名称通常以d结尾，比如 sshd,xinetd,crond 等。
