### wait 和 waitpid 出现的原因
1,当子进程退出的时候，内核会向父进程发送SIG_CHILD信号，子进程的退出是个异步事件（子进程可以在父进程运行的任何时刻终止）
2,子进程退出时，内核将子进程置为僵尸状态，这个进程称为僵尸进程，它只保留最小的一部分内核数据结构，以便父进程查询子进程的退出状态.
3，父进程查询子进程的退出状态可以用wait/waitpid函数
4,waitpid 用来等待某个特定进程的结束
5，返回值
执行成功返回子进程的pid，如果发生错误返回-1（这里结合demo可以看出，这里所有的子进程都回收了，在调用wait就返回-1）
### waitpid 
1,函数功能：用来等待某个特定进程结束
2,函数原型 pid_t waitpid(pid_t pid,int * status,int options)
3,参数 
	status 如果不是空，会把状态信息写道它指向的位置
	options:允许改变waitpid的行为，最有用的一个选项是WHNOHANG，它的作用是防止waitpid把调用者的执行挂起.(如果没有任何已经结束的子进程则马上返回，不予以等待)
	返回值：如果成功返回等待子进程的id,失败返回-1
4,对于waitpid 的pid参数的解释与其值有关
	pid ==-1 等待任一子进程，于是在这一该功能方面waitpid 与 wait等效
	pid>0 等待其进程id与pid相等的子进程
	pid==0 等待其组id相遇调用进程的组id的任一子进程。换句话说是与调用者进程同在一个组的进程
	pid<-1 等待其组id等于pid的绝对值的任意子进程
### linux 退出状态
1,exit 正常退出
2,abort() 其实就是发送 (6)SIGABRT信号，	
### system 函数 查看demo 中的手动实现system 函数
1，system 函数调用 “bin/sh -c command”执行特定的命令，阻塞当前进程知道command命令执行完毕 
2,原型 int system(const * command);
3,返回值
	如果无法启动sehll运行命令，system 将返回127；出现不能执行system
	调用的其他错误返回-1.如果system能够顺利执行，返回那个命令的推出吗
	system 函数执行时，会调用fork,exece,waitpid 等函数
### 计算机系统的中断场景
	中断源发出中断信号，cpu判断中断是否屏蔽，保护现场，cpu执行中断处理程序，cpu恢复现场，继续原来的任务
### 中断的其他概念
	中断向量表保存了中断处理程序的入口地址
	中断个数固定操作系统启动时初始化中断向量表
	中断有优先级（有人敲门，有人打电话，有优先级）
	中断可以被屏蔽（张三可以屏蔽电话）·
### 信号的概念
	信号是unix系统相应某些状态而产生的时间，进程在接受到信号时会采取相应的行动。
	信号是因为某些错误条件产生的，比如内存段冲突，浮点处理器错误 或者非法指令。
	信号是在软件层次上对中断的一种模拟，所以通常是软中断
### 信号与中断的相似点
	1,采用了相同的异步通信方式：
	2,当检测出有信号或中断请求时，都暂停正在执行的程序而转去执行相应的处理程序。
	3,都在处理完毕后返回到原来的断点。
	4,对信号或中断都可以屏蔽。
### 信号与中断的区别
	1, 中断有优先级，而信号没有优先级，所有的信号都是平等的。
	2, 信号处理程序是在用户态下运行的，而中断处理程序是在核心态下运行。
	3,中断响应是及时的，而信号相应通常有较大的时间延迟。
### 常见的信号
	SIGABRT 进程停滞运行 6 
	SIGALRM 警告钟表
	SIGFPE算术运算例外
	SIGHUP 系统挂断
	SIGILL 非法指令
	SIGINT 终端终端2
	SIGKILL 停止进程（此信号不能被忽略或捕获）
	SIPIPE 向没有读者的管道写入数据
	SIGSEGV 无效内存段访问
	SIGQUIT 终端退出 3
	SIGTERM 终止
	SIGUSR1 用户定义信号
	SIGUSR2 用户定义信号2
	SIGCHILD 子进程已经停止或退出
	SIGCONT 如果被停止则继续执行
	SIGTOP 停止执行
	SIGSTP终端停止信号
	SIGTOUT 后台进程请求进行写操作
	SIGTIN 后台进程请求进行写操作

### signal （int signum__sighandler_t handler）
	1 signal 是一个待signum  和 handler
	两个参数的函数，准备捕捉或者屏蔽的i新年好有参数signum
	给出，接受到指定信号时将要调用的函数由handler 给出
	2 handler 这个函数必须有一个int
	类型的参数（即接受到信号代码）它本身的类型是void
    3, handler 也恶意是两个特殊值 SIG_IGN 屏蔽该信号  SIG_DEL 恢复默认行为	
### pause ()
	函数可以被中断(进入睡眠状态),直到信号(signal)所中断。返回值：只返回-1.
	错误代码：EINTR 有信号到达中断了此函数
### man 手册
	1 ,标准命令
	2,系统调用
	3,库函数
	4,设备说明
	5,文件格式
	6,游戏和娱乐
	7,杂项
	8,管理员命令
	9,其他(linux 特定),用来存放内核例行程序的文档
### 信号的分类 信号分为可靠信号和不可靠信号
	1, 实时信号都是可靠信号 kill -l 34-62 是可靠信号.机制能保证。
	比如：发了两个信号，确实能收到2个信号，如果不能收到2个信号，也能告诉你。
	2, 非实时信号是不可靠信号 kill-l 1-31 都是不可靠信号
	比如：向应用程序发送3个信号，有可能只收到1个信号 所以是不可靠的。 
	3,现在的linux 说的不可靠信号，主要是指信号的可能丢失。 
	4，历史：时间的发展，实践证明，有必要对信号的原始机制加以改进和扩充。力图实现“可靠信号” 。由于原来的信号已经广泛应用。不好在做改动。最终增加了一些信号。就是34-36信号
	开始就把他们定义为可靠信号，这些信号支持排队，不会丢失。同时信号的发送和安装也出现了新的版本：信号的发送函数sigqueue()
	以及 信号的安装函数 sigaction() 
	5,signal() 和 sigaction() 函数都是调用内核服务函数do_signal()
	内核服务函数（应用系统无法调用的函数）
	6,非实时信号都不支持排队，都是不可靠信号，实时信号都支持排队，都是可靠信号。
### 进程对信号的处理
	1,忽略信号 有两个信号不能被忽略  9号 信号 和 sigstop 信号。
	2,捕获并处理信号
	3,执行默认操作
### kill函数
	1,发送信号的有Kill 函数和raise 函数。raise 向自身进程发送信号。kill
	可以向自己也可以向其他进程发送信号。
	int kill(pid_t pid,int sig)
	int raise(int signo)
### sleep 函数	是可中断睡眠
	1,wait 进程休眠，除了子进程退出 也有别的信号让父进程醒来了。
	2,man sleep。返回0 ，正常退出。大于0 可能被唤醒。 使用do while 的形式
	~~~
	do {
		n = sleep(n);	
	}while(n > 0);
	~~~
