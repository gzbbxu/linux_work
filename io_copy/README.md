### 阻塞IO
 	数据没有准备好，读操作就会阻塞
	数据不能立即被收时，写操作就会阻塞
	打开文件时阻塞，直到某些条件发生。
### 非阻塞IO
	立即返回，并用错误值来表示当前的状态。
	打开时指定O_NONBLOCK 的标志。
	使用fcntl打开或关闭非阻塞方式。
网络编程时，使用非阻塞，用轮询方式发送。
使用多线程可以避免使用非阻塞IO,但是同步操作较大。
### 多路IO
 	当程序需要同时从两个输入读数据时。
	使用多进程/多线程，同步复杂，进程线程开销。
	使用非阻塞IO，交替轮询。
	通过信号使用异步IO,无法判断哪个io完成。
	多路io: 把关心的io放入一个列表，调用多路函数。
	多路io函数阻塞，直到有一个IO数据准备好后返回。
	返回后告诉调用者哪个描述符准备好了。
### select 实现说明
	调用select 时，通过参数告诉内核用户感兴趣的io描述符
	关心的io状态，输入，输出或者错误
	调用者等待的时间。
	返回之后内核会告诉调用者有多少个文件描述符准备好了
	哪些描述符发生了变化。
	调用返回后对准备好的描述符调用读写操作。
	不关心的描述符传NULL

#connect 为什么要这么做（demo中）
	1，tcp ip 在客户端连接服务器的时候，如果异常，connect
	在fd是阻塞的情况下，返回的是1.5RTT(时间可能是)
	2，sockfd 变成非阻塞。
	先试着调用connect 
	如果网络号，啊马上建立连接
	如果网络不好，则根据返回值。
	if(ret<0 && ern == EINPROGRESS) 表示客户端和服务端正在建立连接。。
	我们等一等。
	等待的时间，我们自己可以控制
	把select 中心加上，
	相当于 我们通过select 管理中心去监控sockfd..
	这样会大大提高我们产品质量。
	注意：
	select 机制监控到conn 可读，并不代表连接是可用的。
	还需要做进一步的判断（造成可读有几种结果：1，真正的建立起来，
	2,建立失败（失败会回写失败信息造成可读））
	通过int  sockoptret = getsockopt(fd,SOL_SOCKET,SO_ERRNO,&err,&socklen);
	做一个容错即可。

